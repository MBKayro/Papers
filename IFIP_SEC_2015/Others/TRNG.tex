\textit{Phase-Locked Loop PLL}
In 2002 Viktor Fischer and Milos Drutarovsky, propose a analysis about extracting randomness from jittel of the PLL implemented on FPGA. their studies is based on knowing that The jitter is detected by the sampling of a reference ($F_{CLK}$) signal using a correlated signal synthesized in the PLL ($F_{CLG}$) where $F_{CLG}=F_{CLK}(K_{M}/K_{D})$, and secondly the maximum distance between the two clock (CLK,CLG) must be minimum $MAX(\Delta T_{min})< \sigma_{jit}$. However they confirm in ideal environment condition without jitter the sampled output or random is deterministic under a period of , then they conclude in a real condition  the randomness is not deterministic and depending on jitter distribution where the $MAX(\Delta T_{min})= {T_{CLK}*GCD(2K_{M},K_{D})}/{4K_{M}})$.  

In 2006 Martin Simka et al, The authors demonstrate by taking 2002 as model that by combined more than one PLL even parallel or series, can increase significantly sensitivity on the jitter $S=F_{CLK}MAX(\Delta T_{min})$ and the output-bit of the generator compared to the use of one PLL. The configuration of multiple PLL are based on input/output length, CVO frequency and MUL/DIV factors ($K_{M}/K_{D}$).In 2011 Martin Simka et al, test the impact of the temperature as depended physical environment of PLL and illustrate that with low bandwidth of PFF cause a higher number of the critical samples, decreases the output jitter and thus increase the tracking jitter. As in application, in 2008 Michal Varchola et al explore embedded system application of TRNG based PLL to extract randomness from the jitter and propose two version where the slower 40kbps can pass the tests.

%%%%%%
\textit{Ring oxialltor RO}
In 2003 K.H.Tsoi et al , Two FPGA based implementations of random number generators intended for embedded cryptographic applications are presented. The first is a true random number generator (TRNG) which employs oscillator phase noise, and the second is a bit serial implementation of a Blum Blum Shub (BBS) pseudorandom number generator (PRNG). the TRNG, oscillator phase noise was used. our implementation uses a very high frequency clock (up to 400 MHz) and does not require a scrambler to achieve good random output. There are several factors which affect the randomness of the output [22]. The first situation is that the duty cycle of Fh may not be 50%. 
In this situation, Fr will have unequal probability of being zero or one. the only off-chip components being two resistors and a capacitor for the TRNG low frequency oscillator. PRNG is a bit serial arithmetic logic unit (ALU). The BBS PRNG performs three functions: seed validation, squaring and modulo operations. Seed validation is
performed once only during initialization, and after that, a squaring and modulo operation are performed each iteration to produce Xi, In total, each iteration of the PRNG requires $(4.5*n^{2} + n)$ clock cycles, where n is the size of the modules in bits.

In 2004 Paul Kohlbrenner et Kris Gaj, propose a TRNG based on two ring oscillators clocked by different clock generated by an internal PLL on FPGA, and with low area implement by only one CLB slice. the authors also extract the jitter of the 2 RO using a simpler and eliminate any correlation between successive bits.

In 2006 Drie Schellekens and al, a review on Ring oxialltor definition [6][7]

IN 2007 Markus Dichtl et Jovan Dj.Golic, The main objective of this work is to evaluate and analyze the amount of true randomness produced by these oscillators. This is achieved by using the restart approach, which consists in repeating the experiments from identical starting conditions. Fibonacci and Galois ring oscillators [8] (FIRO and GARO, respectively) are both defined as generalizations of a ring oscillator (RO). They consist of a number, r, of inverters connected in a cascade together with a number of XOR logic gates forming a feedback in an analogous way. the feedback polynomial should be chosen to have a form $f(x) = (1+x)h(x)$. To increase randomness and robustness, it is also proposed to use an
XOR combination of a FIRO and a GARO (FIGARO). compare them with a classical RO based inverters, show very clearly that the classical ROs need more than 5 until they reach an approximately stable value and the FIROs and GAROs achieve a more or less stable standard deviation of their output voltages already after about 50.

In 2009 KnutWold et Chik How Tan, In this paper, we analyze the TRNG designed by Sunar et al. (2007) based on XOR of the outputs of several oscillator rings. We propose an enhanced TRNG with better randomness characteristics that does not require postprocessing and passes the statistical tests. We have shown by experiment that the frequencies of the equal length oscillator rings in the TRNG are not identical. The difference is due to the placement of the inverters in the FPGA and the resulting routing between the inverters. In this paper, we examine more closely the TRNG based on oscillator rings proposed by Sunar et al. [2]. We show that the TRNG described in [2] is not random without postprocessing our TRNG has no bias and, therefore, no need for complicated postprocessing. The TRNG consists of several equal length oscillator rings connected to an XOR tree. The output from the XOR tree is sampled by a D flip-flop, and the output signal of the D flip-flop is then postprocessed in order to increase the entropy and remove bias from the random signal. The entropy source of the TRNG is the jitter created by each oscillator ring. The main concern of the authors of [10] is that the XOR-tree and the sampling D flip-flop cannot handle the high number of transitions from the oscillator rings. we suggest an enhancement of the TRNG based on the oscillator rings in [2] by adding an extra D flip-flop after each ring. The frequency will increase with the decreasing number of inverters. The tendency is that the bias increases with the increasing number of rings. however equal length oscillator rings will have the same frequency is not true when the dispersion is decreasing with increasing number of inverters. for restart experiment, the first data bits should be omitted in order to have good quality of the random sequence.

In 2009 Cristian Klein et al, This paper focuses on the design and implementation of a high-quality and high-throughput true-random number generator (TRNG) in FPGA. Our first attempt was to create a TRNG based on [3], which uses one RO to sample the output of the other RO. We appreciated this approach due to the fact that the whole stream before the post-processing phase is random (although it might be biased a little bit). A post-processing phase is required which consists in a resilience function. A single inverter allows us to create ROs which both even and odd number of latches. To make sure that the inverter does not add more delay the inverter and the first latch are mapped to the same CLB. we chose as the resilience function a simple XOR of 2r-bits. increases the output period of the ring oscillators, it also increases the amount of jitter. 

%%%%%
\textit{self-timed ring STR}

In 2013 Abdelkarim Cherkaoui et al, The proposed true random number generator (TRNG) exploits the jitter of events propagating in a self-timed ring (STR) to generate random bit sequences at a very high bit rate. the stochastic models are not feasible or at least not plausible, because they combine intrinsically pseudo randomness with true randomness. 
In [9], we showed for the first time that self-timed rings (STR) are a highly suitable source of entropy. Based on these observations, in [10] we proposed the first TRNG principle based on STRs. Self-timed rings (STR) are oscillators that can provide events which are evenly spaced in time and distributed over half an oscillation period of one ring stage. Contrary to inverter ring oscillators, several events can propagate simultaneously in STRs thanks to the asynchronous hand- shake protocol. The signals resulting from the STR outputs are synchronized and their mutual position does not change over time. In contrast, the ring oscillator output signals from [7] drift in time and generate pseudo-randomness.

%%%%
metastability: